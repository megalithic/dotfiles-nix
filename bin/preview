#!/usr/bin/env bash

# Ensure UTF-8 encoding for unicode character support
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8

source "$HOME/bin/helpers"

[ "$1" = "" ] && exit 1

# Convert hex color format to ANSI escape sequence
# Usage:
#   color_code "[bg#395d6f]"  # Returns ANSI code
#   echo "text [fg#395d6f]colored[reset]" | colorize  # Pipe through colorize
# Returns: ANSI escape code for 24-bit true color
color_code() {
  local input="$1"

  # Extract type (fg/bg) and hex color using regex
  if [[ "$input" =~ \[(fg|bg)#([0-9a-fA-F]{6})\] ]]; then
    local type="${BASH_REMATCH[1]}"
    local hex="${BASH_REMATCH[2]}"

    # Convert hex to RGB decimal values
    local r=$((16#${hex:0:2}))
    local g=$((16#${hex:2:2}))
    local b=$((16#${hex:4:2}))

    # Generate ANSI escape code
    # 38;2 = foreground RGB, 48;2 = background RGB
    if [[ "$type" == "fg" ]]; then
      printf '\033[38;2;%d;%d;%dm' "$r" "$g" "$b"
    else
      printf '\033[48;2;%d;%d;%dm' "$r" "$g" "$b"
    fi
  else
    # Return empty if format doesn't match
    return 1
  fi
}

# Process string and replace all color codes with ANSI sequences
# Usage: echo "text [fg#395d6f]colored[reset] text" | colorize
# Or: colorize "text [fg#395d6f]colored[reset] text"
colorize() {
  local input

  # Read from stdin if available, otherwise use argument
  if [ -p /dev/stdin ]; then
    input=$(cat)
  else
    input="$1"
  fi

  # Replace all [fg#XXXXXX] patterns
  while [[ "$input" =~ (\[fg#[0-9a-fA-F]{6}\]) ]]; do
    local match="${BASH_REMATCH[1]}"
    local code=$(color_code "$match")
    input="${input//$match/$code}"
  done

  # Replace all [bg#XXXXXX] patterns
  while [[ "$input" =~ (\[bg#[0-9a-fA-F]{6}\]) ]]; do
    local match="${BASH_REMATCH[1]}"
    local code=$(color_code "$match")
    input="${input//$match/$code}"
  done

  # Replace [reset] with reset code
  input="${input//\[reset\]/$(printf '\033[0m')}"

  printf "%s" "$input"
}

# Helper to reset color
reset_color() {
  printf '\033[0m'
}

handle_image() {
  case "$1" in
  image/*)
    # # Check if we're in a terminal that supports kitty graphics protocol
    # if [[ "$TERM" == *"kitty"* ]] || [[ "$TERM" == *"ghostty"* ]]; then
    # Use fzf preview dimensions if available, otherwise default
    local width="${FZF_PREVIEW_COLUMNS:-80}"
    local height="${FZF_PREVIEW_LINES:-40}"
    # kitty icat --clear --transfer-mode=file --stdin=no --place="${width}x${height}@0x0" "$2"
    kitty icat --clear --transfer-mode=file --stdin=no --place=200x200@10x0 "$2"
    # else
    #   # Fallback to exiftool if graphics protocol not supported
    #   exiftool -All "$2"
    # fi
    ;;
  *) exiftool -All "$2" ;;
  esac
}

handle_text() {
  local input="$1"
  case "$input" in
  *.md) CLICOLOR_FORCE=1 COLORTERM=truecolor glow -p -s dark -w 150 "$input" ;;
  *.htm | *.html) links -dump "$input" ;;
  # *.json | *.jsonc | *.json5) jq --color-output '"$@"' <<<"$input" ;;
  *) bat --theme=base16 --color=always --style=numbers --line-range :300 "$input" ;;
  esac
}

test -d "$HOME/.cache/fzf" || mkdir -p "$HOME/.cache/fzf"
cache="$HOME/.cache/fzf/thumbnail.$(stat "$(readlink -f "$1")" | sha256sum | awk '{print $1}')"
mime="$(file --mime-type -b "$1")"
fullpath="$(printf "%s\n" "$(readlink -f "$1")")"
width="${FZF_PREVIEW_COLUMNS:-$(tput cols)}"

# Alternative characters: ─ (box drawing), ━ (heavy), ═ (double), ▁ (lower block), ‾ (overline), 🮏🮑🮏▁‾▁▁ ─ ▄─▁-_‾
printf "░   -> $yellow$mime$reset\n"
printf "░ 󰙅  -> $blue$fullpath$reset\n"
printf "$dark_grey%${width}s\n$reset" | sed 's/ /‾/g'
printf "\n"

case "$1" in
*.md) handle_text "$1" ;;
*.htm | *.html) handle_text "$1" ;;
*.tgz | *.tar.gz) tar tzf "$1" ;;
*.tar.bz2 | *.tbz2) tar tjf "$1" ;;
*.tar.txz | *.txz) xz --list "$1" ;;
*.tar) tar tf "$1" ;;
*.zip | *.jar | *.war | *.ear | *.oxt) unzip -l "$1" ;;
*.rar) unrar l "$1" ;;
*.7z) 7z l "$1" ;;
*.[1-8]) man "$1" | col -b ;;
*.o) nm "$1" ;;
*.torrent) transmission-show "$1" ;;
*.iso) iso-info --no-header -l "$1" ;;
*.odt | *.ods | *.odp | *.sxw) odt2txt "$1" ;;
*.doc) catdoc "$1" ;;
*.docx) docx2txt "$1" - ;;
*.xls | *.xlsx) ssconvert --export-type=Gnumeric_stf:stf_csv "$1" "fd://1" | batorcat --language=csv ;;
*.wav | *.mp3 | *.flac | *.m4a | *.wma | *.ape | *.ac3 | *.og[agx] | *.spx | *.opus | *.as[fx] | *.mka) exiftool "$1" ;;
*.svg)
  [ ! -f "${cache}.jpg" ] && convert "$1" "${cache}.jpg"
  handle_image "image/*" "${cache}.jpg"
  ;;
*)
  # [mime-type matchers] --------------------------------------------------------------------------
  case "$mime" in
  text/*) handle_text "$1" ;;
  inode/directory) eza -ahFT -L=1 --color=always --icons=always --sort=size --group-directories-first "$1" ;;
  inode/symlink) printf "symlink to: \e[34m%s\e[0m." "$(readlink "$1")" ;;
  application/json)
    handle_text "$1"
    ;;
    # case "$mime" in
    # *.json | *.jsonc | *.json5) jq --color-output '"$@"' <<<"$1" ;;
    # *.toml | *.tml) yq --color-output <"$1" ;;
    # *.yaml | *.yml) yq --color-output <"$1" ;;
    # esac
    # ;;
  # application/yaml) yq --color-output <"$1" ;;
  # application/x-bittorrent) transmission-show --unsorted "$1" ;;
  application/x-executable | application/x-pie-executable | application/x-sharedlib) readelf --wide --demangle=auto --all "$1" ;;
  application/zip) atool --list "$1" ;;
  application/x-x509-ca-cert) openssl x509 -text -noout -in "$1" ;;
  application/pdf)
    pdftoppm -jpeg -f 1 -singlefile "$1" "$cache"
    handle_image "image/*" "$cache.jpg"
    ;;
  application/*) handle_text "$1" ;;
  image/*) handle_image "$mime" "$1" ;;
  video/*)
    ffmpegthumbnailer -i "$1" -o "${cache}.jpg" -s 200
    handle_image "image/*" "${cache}.jpg"
    ;;
  font/* | application/vnd.ms-opentype)
    echo "previewing font.."
    preview_font "$1"
    ;;
  *)
    log_error "oops; no handler found"
    exit 1
    ;;
  esac
  ;;
esac
