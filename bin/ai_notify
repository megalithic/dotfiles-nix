#!/bin/bash

# Smart Notification Helper Script for OpenCode/AI Agents
# Provides intelligent multi-channel notifications based on user attention state

# Temporary directory for tracking pending questions
NOTIFY_STATE_DIR="${TMPDIR:-/tmp}/ai_notify_state"
mkdir -p "$NOTIFY_STATE_DIR"

# Cache directory for contact information (XDG compliant)
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/ai_notify"
CACHE_FILE="$CACHE_DIR/contact_info.cache"
mkdir -p "$CACHE_DIR"

# Default TTL: 7 days (604800 seconds), configurable via AI_NOTIFY_CACHE_TTL
CACHE_TTL="${AI_NOTIFY_CACHE_TTL:-604800}"

# Get cached value with TTL check
# Returns: cached value if valid, empty string if expired or missing
get_cached_value() {
  local key="$1"

  if [ ! -f "$CACHE_FILE" ]; then
    return 1
  fi

  # Read cache file and find the key
  local cached_line=$(grep "^${key}=" "$CACHE_FILE" 2>/dev/null)

  if [ -z "$cached_line" ]; then
    return 1
  fi

  # Extract timestamp and value: KEY=timestamp|value
  local cache_data="${cached_line#*=}"
  local cached_timestamp="${cache_data%%|*}"
  local cached_value="${cache_data#*|}"

  # Check if cache is still valid
  local current_time=$(date +%s)
  local elapsed=$((current_time - cached_timestamp))

  if [ $elapsed -ge $CACHE_TTL ]; then
    # Cache expired
    return 1
  fi

  # Cache valid, return value
  echo "$cached_value"
  return 0
}

# Set cached value with current timestamp
set_cached_value() {
  local key="$1"
  local value="$2"
  local current_time=$(date +%s)

  # Create or update cache file
  local temp_file="${CACHE_FILE}.tmp"

  # Copy existing cache entries (excluding the key we're updating)
  if [ -f "$CACHE_FILE" ]; then
    grep -v "^${key}=" "$CACHE_FILE" > "$temp_file" 2>/dev/null || true
  fi

  # Add new cache entry
  echo "${key}=${current_time}|${value}" >> "$temp_file"

  # Atomically replace cache file
  mv "$temp_file" "$CACHE_FILE"
}

# Get phone number from macOS Contacts (with caching)
get_phone_number() {
  # Try to get from cache first
  local cached_phone=$(get_cached_value "PHONE_NUMBER")

  if [ -n "$cached_phone" ]; then
    echo "$cached_phone"
    return 0
  fi

  # Cache miss or expired - fetch from Contacts
  # Get the full name of the logged-in user
  local full_name=$(dscl . -read /Users/$(whoami) RealName | tail -1 | sed 's/^ //')

  if [ -z "$full_name" ]; then
    echo "[WARN] Could not retrieve full name for current user" >&2
    return 1
  fi

  # Fetch phone number from Contacts (WITHOUT activate to keep it hidden)
  local phone_number=$(osascript -e "tell application \"Contacts\"
        set thePerson to first person whose name is \"$full_name\"

        -- Try to find iPhone labeled number first
        repeat with aPhone in phones of thePerson
            if (label of aPhone as text) contains \"iPhone\" then
                set phoneValue to value of aPhone
                quit
                return phoneValue
            end if
        end repeat

        -- Last resort: return first phone
        set phoneValue to value of first phone of thePerson
        quit
        return phoneValue
    end tell" 2>/dev/null)

  if [ -z "$phone_number" ]; then
    echo "[WARN] Could not retrieve phone number from Contacts" >&2
    return 1
  fi

  # Cache the phone number and full name
  set_cached_value "PHONE_NUMBER" "$phone_number"
  set_cached_value "FULL_NAME" "$full_name"

  echo "$phone_number"
  return 0
}

# Check if user is paying attention to the agents window
# Returns: 0 if user is NOT paying attention (should notify), 1 if paying attention
should_send_notification() {
  local check_result=$(hs -c "
        local notify = require('notify')
        print(notify.checkAttention())
    " 2>/dev/null)

  # If Ghostty is not frontmost or display is asleep, send notifications
  if [[ "$check_result" == "not_ghostty" ]] || [[ "$check_result" == "display_asleep" ]]; then
    return 0 # Should send notification
  fi

  # If we're inside tmux, check if THIS pane is the active one
  if [ -n "$TMUX" ]; then
    # Get current pane ID
    local current_pane=$(tmux display-message -p '#{pane_id}')
    # Get active pane ID in the current window
    local active_pane=$(tmux display-message -p '#{pane_active}')

    # If this pane is not active, send notification
    if [[ "$active_pane" != "1" ]]; then
      return 0 # Should send notification
    fi

    # Also check if the window is active
    local window_active=$(tmux display-message -p '#{window_active}')
    if [[ "$window_active" != "1" ]]; then
      return 0 # Should send notification
    fi
  fi

  # User is paying attention (Ghostty frontmost AND this tmux pane/window is active)
  return 1 # Should NOT send notification
}

# Check if display is asleep
is_display_asleep() {
  local display_check=$(hs -c "
        local notify = require('notify')
        print(notify.checkDisplayState())
    " 2>/dev/null)

  [[ "$display_check" == "display_asleep" ]] || [[ "$display_check" == "screen_locked" ]] || [[ "$display_check" == "logged_out" ]]
}

# Send macOS Notification (via Hammerspoon)
send_macos_notification() {
  local title="$1"
  local subtitle="$2"
  local body="$3"

  # Escape single quotes for Lua
  local escaped_title="${title//\'/\\\'}"
  local escaped_subtitle="${subtitle//\'/\\\'}"
  local escaped_body="${body//\'/\\\'}"

  hs -c "
    local notify = require('notify')
    notify.sendMacOSNotification('$escaped_title', '$escaped_subtitle', '$escaped_body')
  " 2>/dev/null
}

# Send macOS Notification (via osascript - alternative method)
send_macos_notification_osascript() {
  local title="$1"
  local subtitle="$2"
  local body="$3"

  osascript -e "display notification \"$body\" with title \"$title\" subtitle \"$subtitle\"" 2>/dev/null
}

# Send custom Canvas notification at bottom-left with macOS Sequoia styling
send_canvas_notification() {
  local title="$1"
  local message="$2"
  local duration="${3:-5}"

  # Escape single quotes for Lua
  local escaped_title="${title//\'/\\\'}"
  local escaped_message="${message//\'/\\\'}"

  hs -c "
    local notify = require('notify')
    notify.sendCanvasNotification('$escaped_title', '$escaped_message', $duration)
  " 2>/dev/null
}

# Send Hammerspoon Alert (on-screen overlay)
# For long messages (>25 chars), uses custom canvas notification
send_hammerspoon_alert() {
  local message="$1"
  local duration="${2:-5}"

  # Escape single quotes for Lua
  local escaped_message="${message//\'/\\\'}"

  hs -c "
    local notify = require('notify')
    notify.sendSmartAlert('$escaped_message', $duration)
  " 2>/dev/null
}

# Send iMessage to Phone
send_phone_notification() {
  local message="$1"
  local phone_number=$(get_phone_number)

  if [ -z "$phone_number" ]; then
    echo "[WARN] Could not retrieve phone number" >&2
    return 1
  fi

  # Escape single quotes for Lua
  local escaped_message="${message//\'/\\\'}"

  hs -c "
    local notify = require('notify')
    notify.sendPhoneNotification('$phone_number', '$escaped_message')
  " 2>/dev/null
}

# Main notification function with smart detection
notify_user() {
  local title="$1"
  local message="$2"
  local send_to_phone="${3:-false}"
  local urgency="${4:-normal}"
  local is_question="${5:-false}" # New: mark if this is a question

  # Determine alert duration based on urgency
  local duration=5
  case "$urgency" in
  high) duration=10 ;;
  critical) duration=15 ;;
  esac

  # Check if display is asleep - if so, ALWAYS send phone notification
  if is_display_asleep; then
    echo "[NOTIFY] Display asleep - sending phone notification"
    send_phone_notification "$title: $message"
    return
  fi

  # Check if we should send notifications based on user attention
  local should_notify=0
  if should_send_notification; then
    should_notify=1
  fi

  # Log notification decision
  if [ $should_notify -eq 1 ]; then
    echo "[NOTIFY] User not paying attention - sending notification: $title"
  else
    echo "[NOTIFY] User paying attention - notification suppressed: $title"
  fi

  # If this is a question, track it for retry logic
  if [ "$is_question" = "true" ]; then
    local question_id=$(echo -n "$title$message" | md5 -q)
    local question_file="$NOTIFY_STATE_DIR/question_${question_id}"
    echo "$(date +%s)|$title|$message|$send_to_phone|$urgency" >"$question_file"
  fi

  # Send notifications based on attention state
  if [ $should_notify -eq 1 ] || [ "$urgency" = "critical" ]; then
    # 1. macOS Notification Center
    send_macos_notification "$title" "" "$message"

    # 2. Hammerspoon Alert (on-screen overlay)
    send_hammerspoon_alert "ü§ñ $title: $message" "$duration"

    # 3. Phone notification (for important events or if requested)
    if [ "$send_to_phone" = "true" ] || [ "$urgency" = "critical" ]; then
      send_phone_notification "$title: $message"
    fi
  else
    # User is paying attention - only send subtle notification
    send_macos_notification "$title" "" "$message"
  fi
}

# Answer a question (mark it as answered to stop retries)
answer_question() {
  local title="$1"
  local message="$2"
  local question_id=$(echo -n "$title$message" | md5 -q)
  local question_file="$NOTIFY_STATE_DIR/question_${question_id}"

  if [ -f "$question_file" ]; then
    rm "$question_file"
    echo "[NOTIFY] Question answered and removed from retry queue"
  fi
}

# Check for unanswered questions and retry after 5 minutes
retry_unanswered_questions() {
  local current_time=$(date +%s)
  local retry_interval=300 # 5 minutes in seconds

  for question_file in "$NOTIFY_STATE_DIR"/question_*; do
    [ -f "$question_file" ] || continue

    local question_data=$(cat "$question_file")
    IFS='|' read -r timestamp title message send_to_phone urgency <<<"$question_data"

    local elapsed=$((current_time - timestamp))

    # If more than 5 minutes have passed, resend the question
    if [ $elapsed -ge $retry_interval ]; then
      echo "[NOTIFY] Retrying unanswered question ($(($elapsed / 60)) minutes old): $title"

      # Always send to phone for retries, and force notification even if user is active
      send_macos_notification "‚è∞ REMINDER: $title" "" "$message"
      send_hammerspoon_alert "‚è∞ REMINDER: $title: $message" 15
      send_phone_notification "‚è∞ REMINDER - $title: $message"

      # Update timestamp for next retry
      echo "${current_time}|$title|$message|$send_to_phone|$urgency" >"$question_file"
    fi
  done
}

# Background retry daemon (call this once to start monitoring)
start_retry_daemon() {
  (
    while true; do
      sleep 60 # Check every minute
      retry_unanswered_questions
    done
  ) &

  echo $! >"$NOTIFY_STATE_DIR/retry_daemon.pid"
  echo "[NOTIFY] Retry daemon started (PID: $(cat $NOTIFY_STATE_DIR/retry_daemon.pid))"
}

# Stop retry daemon
stop_retry_daemon() {
  if [ -f "$NOTIFY_STATE_DIR/retry_daemon.pid" ]; then
    local pid=$(cat "$NOTIFY_STATE_DIR/retry_daemon.pid")
    kill "$pid" 2>/dev/null
    rm "$NOTIFY_STATE_DIR/retry_daemon.pid"
    echo "[NOTIFY] Retry daemon stopped"
  fi
}

# Parse command-line arguments for 'notify' command
parse_notify_args() {
  local title=""
  local message=""
  local send_to_phone="false"
  local urgency="normal"
  local is_question="false"

  # Check if first arg is JSON
  if [[ "$1" =~ ^\{.*\}$ ]]; then
    # Parse JSON using hs (Hammerspoon has JSON support)
    local json_data="$1"
    title=$(echo "$json_data" | hs -c "print(hs.json.decode([[$json_data]]).title or '')" 2>/dev/null)
    message=$(echo "$json_data" | hs -c "print(hs.json.decode([[$json_data]]).message or '')" 2>/dev/null)
    send_to_phone=$(echo "$json_data" | hs -c "print(tostring(hs.json.decode([[$json_data]]).send_to_phone or false))" 2>/dev/null)
    urgency=$(echo "$json_data" | hs -c "print(hs.json.decode([[$json_data]]).urgency or 'normal')" 2>/dev/null)
    is_question=$(echo "$json_data" | hs -c "print(tostring(hs.json.decode([[$json_data]]).is_question or false))" 2>/dev/null)
  else
    # Parse arguments (supports both short and long options)
    while [ $# -gt 0 ]; do
      case "$1" in
        -t|--title)
          title="$2"
          shift 2
          ;;
        -m|--message)
          message="$2"
          shift 2
          ;;
        -p|--phone|--send-to-phone)
          send_to_phone="$2"
          shift 2
          ;;
        -u|--urgency)
          urgency="$2"
          shift 2
          ;;
        -q|--question|--is-question)
          is_question="$2"
          shift 2
          ;;
        --title=*)
          title="${1#*=}"
          shift
          ;;
        --message=*)
          message="${1#*=}"
          shift
          ;;
        --phone=*|--send-to-phone=*)
          send_to_phone="${1#*=}"
          shift
          ;;
        --urgency=*)
          urgency="${1#*=}"
          shift
          ;;
        --question=*|--is-question=*)
          is_question="${1#*=}"
          shift
          ;;
        --)
          shift
          break
          ;;
        -*)
          echo "Unknown option: $1" >&2
          return 1
          ;;
        *)
          # Positional argument - use for title/message if not set
          if [ -z "$title" ]; then
            title="$1"
          elif [ -z "$message" ]; then
            message="$1"
          elif [ "$send_to_phone" = "false" ]; then
            send_to_phone="$1"
          elif [ "$urgency" = "normal" ]; then
            urgency="$1"
          elif [ "$is_question" = "false" ]; then
            is_question="$1"
          fi
          shift
          ;;
      esac
    done
  fi

  # Validate required arguments
  if [ -z "$title" ] || [ -z "$message" ]; then
    echo "Error: title and message are required" >&2
    return 1
  fi

  # Call notify_user with parsed arguments
  notify_user "$title" "$message" "$send_to_phone" "$urgency" "$is_question"
}

# Command-line interface for direct execution (works from any shell)
# When sourced in bash/zsh, functions are directly available
# When called from fish or as executable, use: ai_notify notify [options]
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
  case "${1:-}" in
    notify)
      shift
      parse_notify_args "$@"
      ;;
    test)
      echo "Smart Notification System Test"
      echo "==============================="
      echo ""
      echo "Checking attention state..."
      if should_send_notification; then
        echo "‚úÖ User NOT paying attention - notifications will be sent"
      else
        echo "‚ö†Ô∏è  User IS paying attention - notifications suppressed"
      fi
      echo ""
      echo "Testing notification (normal priority)..."
      notify_user "Test Notification" "This is a test" false normal
      ;;
    help|--help|-h|"")
      echo "Usage: ai_notify <command> [options...]"
      echo ""
      echo "Commands:"
      echo "  notify [options]"
      echo "    Send a notification with smart detection"
      echo ""
      echo "Options:"
      echo "  -t, --title <title>           Notification title (required)"
      echo "  -m, --message <message>       Notification message (required)"
      echo "  -p, --phone <true|false>      Send to phone (default: false)"
      echo "  -u, --urgency <level>         Urgency: normal|high|critical (default: normal)"
      echo "  -q, --question <true|false>   Mark as question for retry (default: false)"
      echo ""
      echo "Long options also support = syntax:"
      echo "  --title=\"My Title\" --message=\"My Message\" --urgency=high"
      echo ""
      echo "JSON Input:"
      echo "  ai_notify notify '{\"title\":\"...\",\"message\":\"...\",\"urgency\":\"high\"}'"
      echo ""
      echo "Positional Arguments (backward compatible):"
      echo "  ai_notify notify <title> <message> [send_to_phone] [urgency] [is_question]"
      echo ""
      echo "Examples:"
      echo "  # Short options"
      echo "  ai_notify notify -t \"Task Done\" -m \"Tests passed\" -u high"
      echo ""
      echo "  # Long options"
      echo "  ai_notify notify --title \"Task Done\" --message \"Tests passed\" --urgency high"
      echo ""
      echo "  # Long options with = syntax"
      echo "  ai_notify notify --title=\"Task Done\" --message=\"Tests passed\" --urgency=high"
      echo ""
      echo "  # Positional arguments (backward compatible)"
      echo "  ai_notify notify \"Task Done\" \"Tests passed\" false normal"
      echo ""
      echo "  # JSON input"
      echo "  ai_notify notify '{\"title\":\"Build Failed\",\"message\":\"Check logs\",\"urgency\":\"critical\"}'"
      echo ""
      echo "Other Commands:"
      echo "  test    Run notification system test"
      echo ""
      echo "Usage from different shells:"
      echo "  bash/zsh: source ~/.dotfiles-nix/bin/ai_notify && notify_user \"title\" \"message\""
      echo "  fish:     ~/.dotfiles-nix/bin/ai_notify notify -t \"title\" -m \"message\""
      echo "  any:      ai_notify notify -t \"title\" -m \"message\" (if in PATH)"
      ;;
    *)
      echo "Unknown command: $1"
      echo "Run 'ai_notify help' for usage"
      exit 1
      ;;
  esac
fi
