#!/bin/bash

# Smart Notification Helper Script for OpenCode/AI Agents
# Provides intelligent multi-channel notifications based on user attention state

# Temporary directory for tracking pending questions
NOTIFY_STATE_DIR="${TMPDIR:-/tmp}/notifier_state"
mkdir -p "$NOTIFY_STATE_DIR"

# Cache directory for contact information (XDG compliant)
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/notifier"
CACHE_FILE="$CACHE_DIR/contact_info.cache"
mkdir -p "$CACHE_DIR"

# Default TTL: 7 days (604800 seconds), configurable via AI_NOTIFY_CACHE_TTL
CACHE_TTL="${AI_NOTIFY_CACHE_TTL:-604800}"

# Get cached value with TTL check
# Returns: cached value if valid, empty string if expired or missing
get_cached_value() {
  local key="$1"

  if [ ! -f "$CACHE_FILE" ]; then
    return 1
  fi

  # Read cache file and find the key
  local cached_line=$(grep "^${key}=" "$CACHE_FILE" 2>/dev/null)

  if [ -z "$cached_line" ]; then
    return 1
  fi

  # Extract timestamp and value: KEY=timestamp|value
  local cache_data="${cached_line#*=}"
  local cached_timestamp="${cache_data%%|*}"
  local cached_value="${cache_data#*|}"

  # Check if cache is still valid
  local current_time=$(date +%s)
  local elapsed=$((current_time - cached_timestamp))

  if [ $elapsed -ge $CACHE_TTL ]; then
    # Cache expired
    return 1
  fi

  # Cache valid, return value
  echo "$cached_value"
  return 0
}

# Set cached value with current timestamp
set_cached_value() {
  local key="$1"
  local value="$2"
  local current_time=$(date +%s)

  # Create or update cache file
  local temp_file="${CACHE_FILE}.tmp"

  # Copy existing cache entries (excluding the key we're updating)
  if [ -f "$CACHE_FILE" ]; then
    grep -v "^${key}=" "$CACHE_FILE" >"$temp_file" 2>/dev/null || true
  fi

  # Add new cache entry
  echo "${key}=${current_time}|${value}" >>"$temp_file"

  # Atomically replace cache file
  mv "$temp_file" "$CACHE_FILE"
}

# Get phone number from macOS Contacts (with caching)
get_phone_number() {
  # Try to get from cache first
  local cached_phone=$(get_cached_value "PHONE_NUMBER")

  if [ -n "$cached_phone" ]; then
    echo "$cached_phone"
    return 0
  fi

  # Cache miss or expired - fetch from Contacts
  # Get the full name of the logged-in user
  local full_name=$(dscl . -read /Users/$(whoami) RealName | tail -1 | sed 's/^ //')

  if [ -z "$full_name" ]; then
    echo "[WARN] Could not retrieve full name for current user" >&2
    return 1
  fi

  # Fetch phone number from Contacts (WITHOUT activate to keep it hidden)
  local phone_number=$(osascript -e "tell application \"Contacts\"
        set thePerson to first person whose name is \"$full_name\"

        -- Try to find iPhone labeled number first
        repeat with aPhone in phones of thePerson
            if (label of aPhone as text) contains \"iPhone\" then
                set phoneValue to value of aPhone
                quit
                return phoneValue
            end if
        end repeat

        -- Last resort: return first phone
        set phoneValue to value of first phone of thePerson
        quit
        return phoneValue
    end tell" 2>/dev/null)

  if [ -z "$phone_number" ]; then
    echo "[WARN] Could not retrieve phone number from Contacts" >&2
    return 1
  fi

  # Cache the phone number and full name
  set_cached_value "PHONE_NUMBER" "$phone_number"
  set_cached_value "FULL_NAME" "$full_name"

  echo "$phone_number"
  return 0
}

# Get the session context for where this script was called
# Returns: session identifier (tmux session:window or TTY name)
get_session_context() {
  if [ -n "$TMUX" ]; then
    # In tmux: use session:window format
    tmux display-message -p '#S:#W'
  else
    # Not in tmux: use TTY name
    tty | sed 's|/dev/||'
  fi
}

# Check if user is paying attention to THIS specific session
# Returns: 0 if user is NOT paying attention (should notify), 1 if paying attention
should_send_notification() {
  # Get the terminal bundle ID (prefer env var, has default fallback)
  local terminal_bundle_id="${TERMINAL_BUNDLE_ID:-com.mitchellh.ghostty}"

  # Get our calling context (session identifier)
  local calling_context=$(get_session_context)

  # Check if terminal is even focused
  local frontmost=$(hs -c 'local app = hs.application.frontmostApplication(); if app then print(app:bundleID()) end' 2>/dev/null)
  if [ "$frontmost" != "$terminal_bundle_id" ]; then
    return 0 # Send (terminal not focused)
  fi

  # Check display idle state
  local displayIdle=$(hs -c 'print(hs.caffeinate.get("displayIdle"))' 2>/dev/null)
  if [ "$displayIdle" = "true" ]; then
    return 0 # Send (display asleep)
  fi

  # Terminal is focused and display is awake - check if user is viewing THIS specific session
  # Get active window title via Hammerspoon
  local active_title=$(hs -c "local n = require('lib.notifications.notifier'); local bundleId = TERMINAL or '${terminal_bundle_id}'; print(n.getFocusedWindowTitle(bundleId) or '')" 2>/dev/null)

  # If our calling context appears in active window title, user is paying attention to THIS session
  if echo "$active_title" | grep -qF "$calling_context"; then
    return 1 # Don't send (user is actively viewing this session)
  fi

  # Terminal is focused but user is viewing a different session
  return 0 # Send (user not paying attention to this session)
}

# Check if display is asleep
is_display_asleep() {
  local display_check=$(hs -c "
        local notify = require('lib.notifications.notifier')
        print(notify.checkDisplayState())
    " 2>/dev/null)

  [[ "$display_check" == "display_asleep" ]] || [[ "$display_check" == "screen_locked" ]] || [[ "$display_check" == "logged_out" ]]
}

# Send macOS Notification (via Hammerspoon)
send_macos_notification() {
  local title="$1"
  local subtitle="$2"
  local body="$3"

  # Escape single quotes for Lua
  local escaped_title="${title//\'/\\\'}"
  local escaped_subtitle="${subtitle//\'/\\\'}"
  local escaped_body="${body//\'/\\\'}"

  hs -c "
    local notify = require('lib.notifications.notifier')
    notify.sendMacOSNotification('$escaped_title', '$escaped_subtitle', '$escaped_body')
  " 2>/dev/null
}

# Send macOS Notification (via osascript - alternative method)
send_macos_notification_osascript() {
  local title="$1"
  local subtitle="$2"
  local body="$3"

  osascript -e "display notification \"$body\" with title \"$title\" subtitle \"$subtitle\"" 2>/dev/null
}

# send_pushover_notification() {
# "op://Shared/bjdr5wcxdv6eeq3yylc25vvofy/PUSHOVER_USER_TOKEN"
# curl -s -F "token=$TOKEN" -F "user=$USER" -F "message=$*" https://api.pushover.net/1/messages.json > /dev/null
# }

# Send notification via notifier module with AI agent configuration
send_canvas_notification() {
  local title="$1"
  local message="$2"
  local duration="${3:-10}"
  local urgency="${4:-}" # Optional explicit urgency (high, critical, normal)

  # Escape single quotes for Lua
  local escaped_title="${title//\'/\\\'}"
  local escaped_message="${message//\'/\\\'}"

  # Send directly via notifier module with HAL 9000 icon and AI agent settings
  hs -c "
    local notify = require('lib.notifications.notifier')

    local title = [[${title}]]
    local msg = [[${message}]]
    local duration = ${duration}
    local explicitUrgency = '${urgency}'

    local priority
    -- Prefer explicit urgency if provided, otherwise use pattern matching
    if explicitUrgency == 'high' or explicitUrgency == 'critical' then
      priority = 'high'
    elseif explicitUrgency == 'normal' or explicitUrgency == 'low' then
      priority = 'normal'
    else
      -- Fallback to pattern matching
      local isCritical = false
      local criticalPatterns = {'error', 'failed', 'critical', 'urgent', 'question', '?', '!!!'}
      for _, pattern in ipairs(criticalPatterns) do
        if msg:lower():find(pattern:lower(), 1, true) then
          isCritical = true
          break
        end
      end
      priority = isCritical and 'high' or 'normal'
    end

    local config = {
      appImageID = 'hal9000',
      appBundleID = 'org.hammerspoon.Hammerspoon',
      includeProgram = false,
      priority = priority,
    }

    if priority == 'high' then
      config.anchor = 'window'
      config.position = 'C'
      config.dimBackground = true
      config.dimAlpha = 0.6
    else
      config.anchor = 'screen'
      config.position = 'SW'
      config.dimBackground = false
    end

    notify.sendCanvasNotification(title, msg, duration, config)
  " 2>/dev/null
}

# Send Hammerspoon Alert (on-screen overlay)
# For long messages (>25 chars), uses custom canvas notification
send_hammerspoon_alert() {
  local message="$1"
  local duration="${2:-5}"

  # Escape single quotes for Lua
  local escaped_message="${message//\'/\\\'}"

  hs -c "
    local notify = require('lib.notifications.notifier')
    notify.sendSmartAlert('$escaped_message', $duration)
  " 2>/dev/null
}

# Send iMessage to Phone
send_phone_notification() {
  local message="$1"
  local phone_number=$(get_phone_number)

  if [ -z "$phone_number" ]; then
    echo "[WARN] Could not retrieve phone number" >&2
    return 1
  fi

  # Escape single quotes for Lua
  local escaped_message="${message//\'/\\\'}"

  hs -c "
    local notify = require('lib.notifications.notifier')
    notify.sendPhoneNotification('$phone_number', '$escaped_message')
  " 2>/dev/null
}

# Main notification function with smart detection
notify_user() {
  local title="$1"
  local message="$2"
  local send_to_phone="${3:-false}"
  local urgency="${4:-normal}"
  local is_question="${5:-false}" # New: mark if this is a question

  # Determine alert duration based on urgency
  local duration=5
  case "$urgency" in
  high) duration=10 ;;
  critical) duration=15 ;;
  esac

  # Check if display is asleep - if so, ALWAYS send phone notification
  if is_display_asleep; then
    echo "[NOTIFY] Display asleep - sending phone notification"
    send_phone_notification "$title: $message"
    return
  fi

  # Check if we should send notifications based on user attention
  local should_notify=0
  if should_send_notification; then
    should_notify=1
  fi

  # Log notification decision
  if [ $should_notify -eq 1 ]; then
    echo "[NOTIFY] User not paying attention - sending notification: $title"
  else
    echo "[NOTIFY] User paying attention - notification suppressed: $title"
  fi

  # If this is a question, track it for retry logic
  if [ "$is_question" = "true" ]; then
    local question_id=$(echo -n "$title$message" | md5 -q)
    local question_file="$NOTIFY_STATE_DIR/question_${question_id}"
    echo "$(date +%s)|$title|$message|$send_to_phone|$urgency" >"$question_file"
  fi

  # Send notifications based on attention state
  if [ $should_notify -eq 1 ] || [ "$urgency" = "critical" ]; then
    # Canvas notification with HAL 9000 icon (on-screen overlay)
    # Note: We skip macOS notification here because the canvas notification
    # will be caught by the watcher and re-processed, which would override our positioning
    send_canvas_notification "$title" "$message" "$duration" "$urgency"

    # Phone notification (for important events or if requested)
    if [ "$send_to_phone" = "true" ] || [ "$urgency" = "critical" ]; then
      send_phone_notification "$title: $message"
    fi
  else
    # User is paying attention - only send subtle notification
    send_macos_notification "$title" "" "$message"
  fi
}

# Answer a question (mark it as answered to stop retries)
answer_question() {
  local title="$1"
  local message="$2"
  local question_id=$(echo -n "$title$message" | md5 -q)
  local question_file="$NOTIFY_STATE_DIR/question_${question_id}"

  if [ -f "$question_file" ]; then
    rm "$question_file"
    echo "[NOTIFY] Question answered and removed from retry queue"
  fi
}

# Check for unanswered questions and retry after 5 minutes
retry_unanswered_questions() {
  local current_time=$(date +%s)
  local retry_interval=300 # 5 minutes in seconds

  for question_file in "$NOTIFY_STATE_DIR"/question_*; do
    [ -f "$question_file" ] || continue

    local question_data=$(cat "$question_file")
    IFS='|' read -r timestamp title message send_to_phone urgency <<<"$question_data"

    local elapsed=$((current_time - timestamp))

    # If more than 5 minutes have passed, resend the question
    if [ $elapsed -ge $retry_interval ]; then
      echo "[NOTIFY] Retrying unanswered question ($(($elapsed / 60)) minutes old): $title"

      # Always send to phone for retries, and force notification even if user is active
      send_macos_notification "⏰ REMINDER: $title" "" "$message"
      send_hammerspoon_alert "⏰ REMINDER: $title: $message" 15
      send_phone_notification "⏰ REMINDER - $title: $message"

      # Update timestamp for next retry
      echo "${current_time}|$title|$message|$send_to_phone|$urgency" >"$question_file"
    fi
  done
}

# Background retry daemon (call this once to start monitoring)
start_retry_daemon() {
  (
    while true; do
      sleep 60 # Check every minute
      retry_unanswered_questions
    done
  ) &

  echo $! >"$NOTIFY_STATE_DIR/retry_daemon.pid"
  echo "[NOTIFY] Retry daemon started (PID: $(cat $NOTIFY_STATE_DIR/retry_daemon.pid))"
}

# Stop retry daemon
stop_retry_daemon() {
  if [ -f "$NOTIFY_STATE_DIR/retry_daemon.pid" ]; then
    local pid=$(cat "$NOTIFY_STATE_DIR/retry_daemon.pid")
    kill "$pid" 2>/dev/null
    rm "$NOTIFY_STATE_DIR/retry_daemon.pid"
    echo "[NOTIFY] Retry daemon stopped"
  fi
}

# Parse command-line arguments for 'notify' command
parse_notify_args() {
  local title=""
  local message=""
  local send_to_phone="false"
  local urgency="normal"
  local is_question="false"

  # Check if first arg is JSON
  if [[ "$1" =~ ^\{.*\}$ ]]; then
    # Parse JSON using hs (Hammerspoon has JSON support)
    local json_data="$1"
    title=$(echo "$json_data" | hs -c "print(hs.json.decode([[$json_data]]).title or '')" 2>/dev/null)
    message=$(echo "$json_data" | hs -c "print(hs.json.decode([[$json_data]]).message or '')" 2>/dev/null)
    send_to_phone=$(echo "$json_data" | hs -c "print(tostring(hs.json.decode([[$json_data]]).send_to_phone or false))" 2>/dev/null)
    urgency=$(echo "$json_data" | hs -c "print(hs.json.decode([[$json_data]]).urgency or 'normal')" 2>/dev/null)
    is_question=$(echo "$json_data" | hs -c "print(tostring(hs.json.decode([[$json_data]]).is_question or false))" 2>/dev/null)
  else
    # Parse arguments (supports both short and long options)
    while [ $# -gt 0 ]; do
      case "$1" in
      -t | --title)
        title="$2"
        shift 2
        ;;
      -m | --message)
        message="$2"
        shift 2
        ;;
      -p | --phone | --send-to-phone)
        send_to_phone="$2"
        shift 2
        ;;
      -u | --urgency)
        urgency="$2"
        shift 2
        ;;
      -q | --question | --is-question)
        is_question="$2"
        shift 2
        ;;
      --title=*)
        title="${1#*=}"
        shift
        ;;
      --message=*)
        message="${1#*=}"
        shift
        ;;
      --phone=* | --send-to-phone=*)
        send_to_phone="${1#*=}"
        shift
        ;;
      --urgency=*)
        urgency="${1#*=}"
        shift
        ;;
      --question=* | --is-question=*)
        is_question="${1#*=}"
        shift
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo "Unknown option: $1" >&2
        return 1
        ;;
      *)
        # Positional argument - use for title/message if not set
        if [ -z "$title" ]; then
          title="$1"
        elif [ -z "$message" ]; then
          message="$1"
        elif [ "$send_to_phone" = "false" ]; then
          send_to_phone="$1"
        elif [ "$urgency" = "normal" ]; then
          urgency="$1"
        elif [ "$is_question" = "false" ]; then
          is_question="$1"
        fi
        shift
        ;;
      esac
    done
  fi

  # Validate required arguments
  if [ -z "$title" ] || [ -z "$message" ]; then
    echo "Error: title and message are required" >&2
    return 1
  fi

  # Call notify_user with parsed arguments
  notify_user "$title" "$message" "$send_to_phone" "$urgency" "$is_question"
}

# Command-line interface for direct execution (works from any shell)
# When sourced in bash/zsh, functions are directly available
# When called from fish or as executable, use: notifier notify [options]
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
  case "${1:-}" in
  notify)
    shift
    parse_notify_args "$@"
    ;;
  test)
    echo "Smart Notification System Test"
    echo "==============================="
    echo ""
    echo "Checking attention state..."
    if should_send_notification; then
      echo "✅ User NOT paying attention - notifications will be sent"
    else
      echo "⚠️  User IS paying attention - notifications suppressed"
    fi
    echo ""
    echo "Testing notification (normal priority)..."
    notify_user "Test Notification" "This is a test" false normal
    ;;
  help | --help | -h | "")
    echo "Usage: notifier <command> [options...]"
    echo ""
    echo "Commands:"
    echo "  notify [options]"
    echo "    Send a notification with smart detection"
    echo ""
    echo "Options:"
    echo "  -t, --title <title>           Notification title (required)"
    echo "  -m, --message <message>       Notification message (required)"
    echo "  -p, --phone <true|false>      Send to phone (default: false)"
    echo "  -u, --urgency <level>         Urgency: normal|high|critical (default: normal)"
    echo "  -q, --question <true|false>   Mark as question for retry (default: false)"
    echo ""
    echo "Long options also support = syntax:"
    echo "  --title=\"My Title\" --message=\"My Message\" --urgency=high"
    echo ""
    echo "JSON Input:"
    echo "  notifier notify '{\"title\":\"...\",\"message\":\"...\",\"urgency\":\"high\"}'"
    echo ""
    echo "Positional Arguments (backward compatible):"
    echo "  notifier notify <title> <message> [send_to_phone] [urgency] [is_question]"
    echo ""
    echo "Examples:"
    echo "  # Short options"
    echo "  notifier notify -t \"Task Done\" -m \"Tests passed\" -u high"
    echo ""
    echo "  # Long options"
    echo "  notifier notify --title \"Task Done\" --message \"Tests passed\" --urgency high"
    echo ""
    echo "  # Long options with = syntax"
    echo "  notifier notify --title=\"Task Done\" --message=\"Tests passed\" --urgency=high"
    echo ""
    echo "  # Positional arguments (backward compatible)"
    echo "  notifier notify \"Task Done\" \"Tests passed\" false normal"
    echo ""
    echo "  # JSON input"
    echo "  notifier notify '{\"title\":\"Build Failed\",\"message\":\"Check logs\",\"urgency\":\"critical\"}'"
    echo ""
    echo "Other Commands:"
    echo "  test    Run notification system test"
    echo ""
    echo "Usage from different shells:"
    echo "  bash/zsh: source ~/.dotfiles-nix/bin/notifier && notify_user \"title\" \"message\""
    echo "  fish:     ~/.dotfiles-nix/bin/notifier notify -t \"title\" -m \"message\""
    echo "  any:      notifier notify -t \"title\" -m \"message\" (if in PATH)"
    ;;
  *)
    echo "Unknown command: $1"
    echo "Run 'notifier help' for usage"
    exit 1
    ;;
  esac
fi
